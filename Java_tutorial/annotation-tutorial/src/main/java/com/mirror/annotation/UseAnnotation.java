package com.mirror.annotation;

/**
 * @author mirror
 */
public class UseAnnotation {
    /*
     * 虽然并不想吐槽，但有没有发现从反射开始
     * 文档逐渐趋于正规了
     * 在这些主类中不会写main方法
     * 而这些也是逐渐让其偏向正规的代码编写
     * 虽然这样有点无聊，因为从建这个项目的时候就是一个十分正规的项目
     *
     * 好了，不吐槽了，敢在这发牢骚是因为
     * 剩下的基本上就属于看看就好，是需要牢记的概念
     * 也不多，而且前面因为偷懒已经用了很多的注解了
     * lombok，还有test的 。能少写点代码就少写点
     *
     * 所以也能看出来了
     * 所谓注解，只是让我们少写代码，还有让编译器注意到这里需要特别关照。
     * 说起来也算是拓展功能来着。
     *
     * 至于这为什么，还记得之前打印类的时候，写代码却发现弹出的有getAnnotation方法么，在反射的时候
     * 所以注解是在Java元数据中的，也就是初始化必须的
     *
     * 关于如何写一个注解，只能说到AOP的时候有的机会是要写。别问为啥，问就是痛
     */

    /*
    注解，就是放在Java源码的类，方法，字段，参数之前的一种特殊注释

    注解主要分为三类
    第一类是由编译器使用的注解，
    例如： @Override：让编译器检查该方法是否正确地实现了覆写；
    @SuppressWarnings：告诉编译器忽略此处代码产生的警告。
    这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。

     第二类是由工具处理.class文件使用的注解，
     比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。
     这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。
     这类注解只被一些底层库使用，一般我们不必自己处理。

      第三类是在程序运行期能够读取的注解，
      它们在加载后一直存在于JVM中，这也是最常用的注解。
      例如，
      一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）
     */

    /*
    定义一个注解时，还可以定义配置参数。配置参数可以包括：

        所有基本类型；
        String；
        枚举类型；
        基本类型、String、Class以及枚举的数组。
    因为配置参数必须是常量

    配置参数必须是常量
    注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。
     */

    /*
    关于使用注解，更想写怎么定义注解
    毕竟往上面写个太简单了
    首先是定义注解的方式

    @interface
     */
}
